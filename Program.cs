////////////////////////////////////////////////////////////////////////////////////////////////////////////
//---------------------------------------------Interfaces-------------------------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Пример реализации интерфейса классом
using System.Reflection.Metadata;

JustClass justClass = new(){Lol = "asd"}; // Создаём экземпляр класса, который реализует интерфейс
justClass.Print();

// Интерфейс - это ссылочный тип, кторый может определять некий функционал, но не иметь его реализации.
// Функционал, определёлеый интерфейсом может реализовывать класс или стркутура, и если они реализуют
// функционал, то обязоны реализовать весь. Иинтерфейс является контрактом реализации зараенее 
// определённого функционала, что позволяет определять объекты с похожим поведением, таким образом
// реализуется полиморфизм.
// Пример: есть метод, который в качестве параметра мпринимает интерфейс. Технически в такой метод мы
// можем передать любой объект, реализующий конкретный интерфейс и это гарантирует нам, что передаваемый
// объект точно будет соответсвовать определённым критериям и при попытке ображения к какому либо элементу
// или функционалу класса, не возникнет проблем ввиду его несовместимости 
// Для объявления интерфейса, используется ключевое interface, как правило интерфейс именуется с буквой "I"
// в начале.
// 
// Что может поределять интерфейс:
// 1) Методы
// 2) Свойства
// 3) Индексаторы
// 4) События
// 5) Статические поля и константы с версии C# 8
// Важно: интерфейс не можнет определять нестатические ПЕРЕМЕННЫЕ.
// Наследлвание от интерфейса "класс / стркутура : интерфейс" называется реализацией
// Если члены интерфейса не имеют модификатора, то по умолчанию, они public(публичны), 
// т.к. цель интерфейсов, определение функционала, для реализации его классом или структурой. 
// Тем не менее, начиная с .NET 8, мы можем явно указать модификаторы доступа, в том числе
// и private 
//
// Пример реализации интерфейса классом:

interface Iinterface 
{
    public string Lol { set; } // Определяем свойство
    public void Print(); // Определяем метод
}

class JustClass : Iinterface
{
    public string Lol { set => _lol = value; } // Реализуем свойство
    private string? _lol;
    public void Print() // Реализуем метод
    {
        Console.WriteLine($"{_lol}");
    }
}

// По умолчанию, интерфейсы, как и классы имеют модификатор доступа internal
// это значит, что использовать его, мы можем только в текущем проекте, но
// с помощью public, мы можем сделать его общедоступным.
//
// Так же, начиная с версии .NET 8, интерфейсы могут реализовывать функцилнал
// по умолчанию. P.S. тут я немного не понял, зачем это нужно, если у нас есть
// абстрактные классы, похоже, в таком случае смысл интерфейсов немного 
// теряется, на данный момент, на счёт этого не могу выдыинуть твёрдых теорий.
// Тем не менее, без серьёзной необходимости, эту возможность стоит обходить
// стороной.
//
// Тем не менее, приведу пример:

interface Iinterface1
{
    
}

class Base : Iinterface1
{

}


